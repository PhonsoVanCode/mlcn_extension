import { INotebookModel, INotebookTracker } from "@jupyterlab/notebook";

/**
 * Sends a prompt to the OpenAI ChatGPT API and returns generated Python code and Markdown.
 *
 * This function prepares a system prompt describing the coding assistant's role in a JupyterLab extension,
 * including formatting instructions for code and markdown outputs. It attaches the current notebook's JSON
 * representation for context. The API response is parsed to extract code and markdown sections, marked by
 * specific delimiters.
 *
 * The request is automatically aborted after 10 seconds (timeout) using AbortController.
 *
 * Error handling:
 * - On timeout, network errors, or CORS errors, the method returns immediately and provides an error message in the markdownoutput.
 * - On other errors (e.g., JSON parsing), an error message is also returned in markdownoutput.
 * - codeoutput is empty or contains a hint in case of errors.
 *
 * @param prompt - The user prompt to send to ChatGPT.
 * @param tracker - JupyterLab notebook tracker for accessing the current notebook.
 * @returns Promise resolving to an object with generated Python code (`codeoutput`) and Markdown (`markdownoutput`).
 *
 * @remarks
 * - Expects code between `CODEBEGINN` and `CODEEND`, and markdown between `MARKDOWNBEGINN` and `MARKDOWNEND`.
 * - Handles API errors, network errors, and timeouts gracefully.
 */
export async function callChatGPT(prompt: string, tracker: INotebookTracker): Promise<{ codeoutput: string, markdownoutput: string }> {
    console.log('>>> callChatGPT() start');

    const notebookModelasJSON = getNotebookAsJSON(tracker);

    /*const roleSystemGer = `
      * du bist ein Coding-Assistent
      * Programmiersprache: Python
      * Entwicklungsumgebung: JupyterLab
      * Du wirst in einer JupyterLab-Extension verwendet - man kann zwischen RAW CODE MARKDOWN umschalten
      * RAW zu CODE -> du verwandelst die RAW Eingabe in ausführbaren Quellcode und in Markdown beschreibst du den Code
      * markiere den CODE am Anfang mit CODEBEGINN
      * markiere den CODE am Ende mit CODEEND
      * markiere das MARKDOWN am Anfang mit MARKDOWNBEGINN
      * markiere das MARKDOWN am Ende mit MARKDOWNEND
      * generiere beides in der Antwort
      * du wirst immer aufgerufen wenn der benutzer von RAW zu CODE oder von RAW zu MARKDOWN wechselt
      * du bekommst das gesamte notebook mitgeschickt, sodass du auch bisher ausgeführten code beachten kannst, z.b. deklarierte variablen
      * die aktuelle Zelle ist mit '# This is under heavy construction...' in der source gekennzeichnet
      * ignoriere im Notebook '# if you want to use the extension, switch to a RAW cell' - ist von der Extension als Hinweis generiert
      * erstelle die antwort in der Sprache, in der der user prompt (input) ist (inline comments and MARKDOWN) unabhängig der Anweisungen in deutsch
      * das aktuelle notebook: ` + JSON.stringify(notebookModelasJSON);*/
    
    const roleSystemEng = `
      * You are a coding assistant
      * Programming language: Python
      * Development environment: JupyterLab
      * You are used inside a JupyterLab extension - the user can switch between RAW and CODE MARKDOWN
      * RAW to CODE -> you transform the RAW input into executable source code and, in Markdown, you describe the code
      * Mark the CODE at the beginning with CODEBEGINN
      * Mark the CODE at the end with CODEEND
      * Mark the MARKDOWN at the beginning with MARKDOWNBEGINN
      * Mark the MARKDOWN at the end with MARKDOWNEND
      * Always generate both (code + markdown) in the answer
      * You are always called when the user switches from RAW to CODE or from RAW to MARKDOWN
      * You receive the entire notebook as context, so you can take into account already executed code, e.g. declared variables
      * The current cell is marked with '# This is under heavy construction...' in its source, remove it in your response
      * Ignore '# if you want to use the extension, switch to a RAW cell' – this is a hint generated by the extension
      * Always create the answer in the same language as the user’s prompt (input) for inline comments and MARKDOWN, regardless of these German instructions
      * The current notebook: ` + JSON.stringify(notebookModelasJSON);

    // Timeout-Handling mit AbortController
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000); // 30 Sekunden

    let response: Response;
    try {
      response = await fetch("https://llm-keyboard.medien.ifi.lmu.de/jupyter/mlcn", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          model: "gpt-4.1",
          messages: [
            { role: "system", content: roleSystemEng },
            { role: "user", content: prompt }
          ]
        }),
        signal: controller.signal
      });
    } catch (error: any) {
      console.error(error);
      return { codeoutput: '# This should never happened :( check MARKDOWN for more', markdownoutput: String(error?.message || error) };
    } finally {
      clearTimeout(timeoutId);
    }

    const data = await response.json();

    const responseBody = data.choices?.[0]?.message?.content || "";

    const codeoutput = (() => {
      const match = responseBody.match(/CODEBEGINN([\s\S]*?)CODEEND/);
      return match ? match[1].trim() : '';
    })();    
    const markdownoutput = (() => {
      const match = responseBody.match(/MARKDOWNBEGINN([\s\S]*?)MARKDOWNEND/);
      return match ? match[1].trim() : '';
    })();

    console.log('>>>>>> codeoutput: ' + codeoutput)
    console.log('>>>>>> markdownoutput: ' + markdownoutput)
    console.log('>>>>>> responseBody: ' + responseBody);
    console.log('>>> callChatGPT() end');

    return { codeoutput, markdownoutput };
}

/**
 * Converts the currently active notebook in the provided tracker to a JSON representation
 * following the Jupyter notebook format.
 *
 * Iterates through all cells in the notebook, extracting their type, source, and metadata.
 * For code cells, also includes execution count and outputs. Returns an object containing
 * the notebook's cells, metadata, nbformat, and nbformat_minor.
 *
 * @param tracker - The notebook tracker containing the current notebook widget.
 * @returns The notebook as a JSON object, or `null` if no notebook is currently active.
 */
function getNotebookAsJSON(tracker: INotebookTracker): any | null {
  const panel = tracker.currentWidget;

  if (!panel) {
    return null;
  }

  const model = panel.context.model;
  const notebookModel = model as INotebookModel;

  const cells = Array.from(notebookModel.cells).map(cell => {
    const base = {
      cell_type: cell.type,
      source: cell.sharedModel.getSource(),
      metadata: cell.metadata
    };

    if (cell.type === 'code') {
      return {
        ...base,
        execution_count: (cell as any).executionCount,
        outputs: (cell as any).outputs.toJSON()
      };
    }

    return base;
  });

  return {
    cells,
    metadata: notebookModel.metadata,
    nbformat: notebookModel.nbformat,
    nbformat_minor: notebookModel.nbformatMinor
  };

}
